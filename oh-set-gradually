#!/usr/bin/python

import argparse
import datetime
import json
import math
import sys
import time
import urlparse

import requests  # http://python-requests.org
import toml      # https://github.com/uiri/toml

start_time = time.time()

parser = argparse.ArgumentParser()
parser.add_argument('-v', '--verbose', action='store_true', help='Be verbose about script actions.')
parser.add_argument(      '--debug', action='store_true', help='Enable debugging output.')
parser.add_argument('-c', '--config', type=argparse.FileType('r'), help='File containing parameters for connecting to an OpenHAB instance.')
parser.add_argument('-H', '--host', help='Name of the host running OpenHAB.  Defaults to localhost.')
parser.add_argument('-p', '--port', help='Port on which to connect to OpenHAB host.  Defaults to 80 for HTTP and 443 for HTTPS.')
parser.add_argument('-s', '--ssl', action='store_const', const=True, help='Use SSL for this connection.')
parser.add_argument(      '--no-ssl', action='store_const', const=False, dest='ssl', help='Do not use SSL for this connection.')
parser.add_argument(      '--start', type=int, help='Starting value for the item.  If unset, the item\'s current value will be used.')
parser.add_argument(      '--end', type=int, help='Ending value for the item.')
parser.add_argument(      '--duration', type=int, help='Duration of time, in seconds.')
parser.add_argument(      '--step', type=int, help='Target step increment for intermediate values.  Defaults to 1.')
parser.add_argument(      '--item', help='Name of the item to modify.')
parser.add_argument('script', nargs='?', type=argparse.FileType('r'), help='Script to run.')
parsed_args = parser.parse_args()

class Config:
    def __init__(self, parsed_args):
        if parsed_args.config is not None:
            config_args = toml.load(parsed_args.config)
        elif parsed_args.script is not None:
            config_args = toml.load(parsed_args.script)
        else:
            config_args = {}

        if parsed_args.host is not None:
            self.rest_hostname = parsed_args.host
        elif 'rest' in config_args and 'host' in config_args['rest']:
            self.rest_hostname = config_args['rest']['host']
        else:
            self.rest_hostname = 'localhost'

        if parsed_args.ssl is not None:
            self.rest_ssl = parsed_args.ssl
        elif 'rest' in config_args and 'ssl' in config_args['rest']:
            if config_args['rest']['ssl'] not in (True, False):
                print >>sys.stderr, 'rest.ssl config must be "true" or "false"'
                exit(1)
            self.rest_ssl = config_args['rest']['ssl']
        else:
            self.rest_ssl = False
            
        if parsed_args.port is not None:
            self.rest_port = parsed_args.port
        elif 'rest' in config_args and 'port' in config_args['rest']:
            if not isinstance(config_args['rest']['port'], (int, long)):
                print >>sys.stderr, 'rest.port config must be an integer'
                exit(1)
            self.rest_port = config_args['rest']['port']
        elif self.rest_ssl:
            self.rest_port = 443
        else:
            self.rest_port = 80

        self.verbose = parsed_args.verbose or parsed_args.debug
        self.debug = parsed_args.debug

class ItemChange:
    @staticmethod
    def from_toml(config, toml_dict, init_time):
        if 'start_time' in toml_dict:
            start_time = init_time + toml_dict['start_time']
        else:
            start_time = init_time
        if 'duration' in toml_dict:
            end_time = start_time + toml_dict['duration']
        else:
            end_time = start_time
        if 'start_value' in toml_dict:
            start_value = toml_dict['start_value']
        else:
            start_value = None

        return ItemChange(config,
                          toml_dict['item'],
                          (start_time, end_time),
                          (start_value, toml_dict['end_value']),
                          toml_dict['step'] if 'step' in toml_dict else None)
    
    def __init__(self, config, item_name, time_bounds, value_bounds, step=None):
        # Basics
        self.config = config
        self.item_name = item_name
        self.start_time = time_bounds[0]
        self.end_time = time_bounds[1]
        self.start_value = value_bounds[0]
        self.end_value = value_bounds[1]
        self.step = step

        self.started = False
        self.current_value = None
        
        if self.start_value is not None:
            self.calculate_params()

    def __repr__(self):
        return '<ItemChange({}: {}..{} {}-{})>'.format(self.item_name, self.start_value, self.end_value, self.start_time, self.end_time)
    
    def set_current_value_from_openhab(self):
        r = requests.get(self.item_url)
        r.raise_for_status()
        s = json.loads(r.text)
        if s['type'] == 'Color':
            self.current_value = int(s['state'].split(',')[-1])
        else:
            self.current_value = int(s['state'])
        if self.config.verbose:
            print '{} {}: fetched current state {}'.format(datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.%f'), self.item_name, self.current_value)

    def calculate_params(self):
        if self.step is None:
            self.step = math.copysign(1, self.end_value - self.start_value)
            
        # Check step direction, fix if necessary.
        implied_step = math.copysign(self.step, self.end_value - self.start_value)
        if self.step != implied_step:
            print >>sys.stderr, '{}: {}..{} sign mismatch: requested {}, but should be {}.'.format(self.item_name, self.start_value, self.end_value, self.step, implied_step)
            self.step = implied_step

        # Set value limits
        if self.step > 0:
            self.max_value = self.end_value
            self.min_value = self.start_value
        else:
            self.max_value = self.start_value
            self.min_value = self.end_value

        # Set linear equation coefficients.
        # y = mx + b
        # In this case,
        #   y = item value
        #   x = time
        #   desired_value = slope * time.time() + intercept
        self.slope = (self.end_value - self.start_value) / (self.end_time - self.start_time)
        self.intercept = self.start_value - self.slope * self.start_time
        if self.config.verbose:
            print '{}: y = {} * x + {}'.format(self.item_name, self.slope, self.intercept)
        
    @property
    def item_url(self):
        return urlparse.urlunsplit(('https' if self.config.rest_ssl else 'http','{}:{}'.format(self.config.rest_hostname, self.config.rest_port), '/rest/items/{}'.format(self.item_name), None, None))

    @property
    def item_state_url(self):
        return self.item_url + '/state'

    @property
    def time_to_next_step(self):
        if not self.started:
            # Not yet started; next time we have to do something is our start time.
            next_time = self.start_time
        elif self.current_value is None or self.end_time <= time.time():
            # Somehow we've started, but haven't set a value yet.  Or it's
            # past our end time.  Either way, do something now.
            return 0
        else:
            # How long will it be before we next need to update?
            next_value = self.current_value + self.step
            next_time = (next_value - self.intercept) / self.slope
        return max(0, next_time - time.time())
        
    def set_item(self):
        # Don't do anything if we're not supposed to start yet.
        if time.time() < self.start_time:
            return
        self.started = True
        if self.end_time <= time.time():
            clamped_value = self.end_value
        else:
            # If the starting value is unset, pull it from the current state on OpenHAB.
            if self.start_value is None:
                self.set_current_value_from_openhab()
                self.start_value = self.current_value
                self.calculate_params()
            clamped_value = min(max(int(round(self.slope * time.time() + self.intercept)),
                                    self.min_value),
                                self.max_value)
        if clamped_value != self.current_value:
            r = requests.post(self.item_url, str(clamped_value))
            r.raise_for_status()
            self.current_value = clamped_value
            if self.config.verbose:
                print '{} {}: {}'.format(datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S.%f'), self.item_name, self.current_value)

config = Config(parsed_args)

if parsed_args.script is not None:
    if parsed_args.start is not None or \
       parsed_args.end is not None or \
       parsed_args.duration is not None or \
       parsed_args.step is not None or \
       parsed_args.item is not None:
        print >>sys.stderr, '--item is mutually exclusive with giving a script.'
        exit(1)
    parsed_args.script.seek(0)
    changes = []
    for c in toml.load(parsed_args.script)['changes']:
        changes.append(ItemChange.from_toml(config, c, start_time))
else:
    end_time = start_time + parsed_args.duration
    changes = [ItemChange(config, parsed_args.item, (start_time, end_time), (parsed_args.start, parsed_args.end), parsed_args.step)]

foo = 0
last_end_time = max([c.end_time for c in changes])
while time.time() < last_end_time:
    # Fixed time reference so all comparisons will be on equal footing.
    loop_start = time.time()
    need_to_prune = False
    for c in changes:
        if loop_start < c.start_time:
            continue
        c.set_item()
        need_to_prune = need_to_prune or c.end_time <= loop_start
    if need_to_prune:
        changes = [c for c in changes if loop_start < c.end_time]
    sleep_time = min([c.time_to_next_step for c in changes])
    if config.debug:
        print '--- Sleeping for {}s.'.format(sleep_time)
    if sleep_time == 0:
        print loop_start, time.time()
        for c in changes:
            print c, c.time_to_next_step
        if foo > 0:
            exit(2)
        foo += 1
    time.sleep(sleep_time)

# Ensure that the final values were hit.
for c in changes:
    c.set_item()
